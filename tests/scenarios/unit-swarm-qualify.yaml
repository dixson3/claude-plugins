name: "Unit: swarm qualification gate"
setup:
  - "mkdir -p .yoshiko-flow"
  - "printf '%s' '{\"enabled\":true,\"config\":{\"artifact_dir\":\"docs\"}}'  > .yoshiko-flow/config.json"

steps:
  # Case 1: swarm_qualify skill file exists
  - name: "qualify_skill_exists"
    run: |
      test -f "$PLUGIN_DIR/plugins/yf/skills/swarm_qualify/SKILL.md" && echo "exists"
    assertions:
      - type: output_contains
        value: "exists"

  # Case 2: Skill has correct name
  - name: "qualify_skill_name"
    run: |
      head -5 "$PLUGIN_DIR/plugins/yf/skills/swarm_qualify/SKILL.md" | grep "name:"
    assertions:
      - type: output_contains
        value: "yf:swarm_qualify"

  # Case 3: plan_create_tasks has Step 9c
  - name: "plan_create_tasks_has_step_9c"
    run: |
      grep "Step 9c" "$PLUGIN_DIR/plugins/yf/skills/plan_create_tasks/SKILL.md"
    assertions:
      - type: output_contains
        value: "Qualification"

  # Case 4: plan_execute has qualification check
  - name: "plan_execute_has_qualification"
    run: |
      grep "swarm_qualify\|qualification\|Step 3e" "$PLUGIN_DIR/plugins/yf/skills/plan_execute/SKILL.md" | head -3
    assertions:
      - type: output_contains
        value: "Qualification"

  # Case 5: plan-exec.sh records start SHA
  - name: "plan_exec_records_start_sha"
    run: |
      grep "start-sha" "$PLUGIN_DIR/plugins/yf/scripts/plan-exec.sh" | head -3
    assertions:
      - type: output_contains
        value: "start-sha"

  # Case 6: plan-exec.sh has qualifying status
  - name: "plan_exec_has_qualifying_status"
    run: |
      grep "qualifying" "$PLUGIN_DIR/plugins/yf/scripts/plan-exec.sh" | head -3
    assertions:
      - type: output_contains
        value: "qualifying"

  # Case 7: plan completion delegates to plan_execute which has Qualification gate
  - name: "completion_report_has_qualification"
    run: |
      grep "plan_execute" "$PLUGIN_DIR/plugins/yf/rules/yf-rules.md" | head -3
      grep "Qualification" "$PLUGIN_DIR/plugins/yf/skills/plan_execute/SKILL.md" | head -3
    assertions:
      - type: output_contains
        value: "plan_execute"
      - type: output_contains
        value: "Qualification"

  # Case 8: version consistency across all files
  - name: "version_consistency"
    run: |
      SOURCE=$(jq -r '.version' "$PLUGIN_DIR/plugins/yf/.claude-plugin/plugin.json")
      MARKET_META=$(jq -r '.metadata.version' "$PLUGIN_DIR/.claude-plugin/marketplace.json")
      MARKET_PLUG=$(jq -r '.plugins[0].version' "$PLUGIN_DIR/.claude-plugin/marketplace.json")
      README_VER=$(sed -n 's/.*| \([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\) |$/\1/p' "$PLUGIN_DIR/README.md" | head -1)
      CLAUDE_VER=$(sed -n 's/.*(\(v[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)).*/\1/p' "$PLUGIN_DIR/CLAUDE.md" | head -1)
      CLAUDE_VER="${CLAUDE_VER#v}"
      MISMATCH=""
      [ "$MARKET_META" != "$SOURCE" ] && MISMATCH="$MISMATCH marketplace.json:metadata($MARKET_META)"
      [ "$MARKET_PLUG" != "$SOURCE" ] && MISMATCH="$MISMATCH marketplace.json:plugin($MARKET_PLUG)"
      [ "$README_VER" != "$SOURCE" ] && MISMATCH="$MISMATCH README.md($README_VER)"
      [ "$CLAUDE_VER" != "$SOURCE" ] && MISMATCH="$MISMATCH CLAUDE.md($CLAUDE_VER)"
      if [ -n "$MISMATCH" ]; then
        echo "MISMATCH: source=$SOURCE$MISMATCH"
        exit 1
      fi
      echo "OK: all version references match $SOURCE"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 9: research-spike formula has planning_safe
  - name: "research_spike_planning_safe"
    run: |
      jq -r '.planning_safe' "$PLUGIN_DIR/plugins/yf/formulas/research-spike.formula.json"
    assertions:
      - type: output_contains
        value: "true"

  # Case 10: preflight.json has single consolidated rule file
  - name: "preflight_rule_count"
    run: |
      COUNT=$(jq '.artifacts.rules | length' "$PLUGIN_DIR/plugins/yf/.claude-plugin/preflight.json")
      echo "count=$COUNT"
      [ "$COUNT" -eq 1 ] && echo "OK: 1 consolidated rule entry"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 11: Default config → qualification mode absent → treated as blocking
  - name: "default_qualification_mode"
    run: |
      rm -f "$WORK_DIR/.yoshiko-flow/config.json"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      export CLAUDE_PROJECT_DIR="$WORK_DIR"
      . "$PLUGIN_DIR/plugins/yf/scripts/yf-config.sh"
      # No config → sanity_check_mode defaults to "blocking"
      MODE=$(yf_sanity_check_mode)
      echo "mode=$MODE"
      [ "$MODE" = "blocking" ] && echo "OK: default is blocking"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 12: plan-exec.sh start records start-sha in labels (verify content)
  - name: "start_sha_content_verified"
    run: |
      cd "$WORK_DIR"
      git init 2>/dev/null || true
      mkdir -p .claude .yoshiko-flow/tasks
      echo '# test' > CLAUDE.md
      echo '{"enabled":true,"config":{"artifact_dir":"docs"}}' > .yoshiko-flow/config.json
      git add -A && git commit -m 'qualify-test' 2>/dev/null
      # Create epic task file
      ROOT="task-qual-001"
      cat > ".yoshiko-flow/tasks/${ROOT}.json" << TASKJSON
      {"id":"${ROOT}","type":"epic","title":"Qualify SHA Test","status":"open","labels":["ys:plan","plan:98"],"created":"2026-01-01T00:00:00Z"}
      TASKJSON
      EXPECTED_SHA=$(git rev-parse HEAD)
      CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plan-exec.sh" start "$ROOT" 2>&1
      # Read the label back from task file
      SHA_LABEL=$(jq -r '.labels[] | select(startswith("start-sha:"))' ".yoshiko-flow/tasks/${ROOT}.json" 2>/dev/null | head -1)
      RECORDED="${SHA_LABEL#start-sha:}"
      echo "expected=$EXPECTED_SHA"
      echo "recorded=$RECORDED"
      [ "$EXPECTED_SHA" = "$RECORDED" ] && echo "OK: start-sha matches HEAD exactly"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 13: plan-exec.sh start sets exec:executing label (task file verification)
  - name: "start_sets_executing_label"
    run: |
      cd "$WORK_DIR"
      ROOT="task-qual-001"
      if [ ! -f ".yoshiko-flow/tasks/${ROOT}.json" ]; then
        echo "SKIP: no test epic available"
        exit 0
      fi
      LABELS=$(jq -r '.labels[]' ".yoshiko-flow/tasks/${ROOT}.json" 2>/dev/null)
      HAS_EXECUTING=$(echo "$LABELS" | grep -c "exec:executing" || echo "0")
      echo "has_executing=$HAS_EXECUTING"
      [ "$HAS_EXECUTING" -gt 0 ] && echo "OK: executing label present"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"
