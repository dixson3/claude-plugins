name: "Unit: formula comment protocol compliance"
setup:
  - "mkdir -p plugins/yf/formulas plugins/yf/rules"

steps:
  # Case 1: All 5 formulas have SUBAGENT annotations
  - name: "all_formulas_have_subagent"
    run: |
      PASS=0
      FAIL=0
      for f in "$PLUGIN_DIR"/plugins/yf/formulas/*.formula.json; do
        NAME=$(basename "$f" .formula.json)
        COUNT=$(grep -c 'SUBAGENT:' "$f")
        if [ "$COUNT" -gt 0 ]; then
          PASS=$((PASS + 1))
        else
          echo "MISSING SUBAGENT in $NAME"
          FAIL=$((FAIL + 1))
        fi
      done
      echo "formulas_with_subagent=$PASS missing=$FAIL"
      [ "$FAIL" -eq 0 ] && echo "OK"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 2: feature-build formula uses correct SUBAGENT types
  - name: "feature_build_subagents"
    run: |
      F="$PLUGIN_DIR/plugins/yf/formulas/feature-build.formula.json"
      EXPLORE=$(grep -c 'SUBAGENT:Explore' "$F")
      GP=$(grep -c 'SUBAGENT:general-purpose' "$F")
      echo "explore=$EXPLORE general-purpose=$GP"
      [ "$EXPLORE" -ge 1 ] && [ "$GP" -ge 1 ] && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 3: bugfix formula references FINDINGS, CHANGES, TESTS comment types
  - name: "bugfix_comment_types"
    run: |
      F="$PLUGIN_DIR/plugins/yf/formulas/bugfix.formula.json"
      FINDINGS=$(grep -c 'FINDINGS:' "$F")
      CHANGES=$(grep -c 'CHANGES:' "$F")
      TESTS=$(grep -c 'TESTS:' "$F")
      echo "findings=$FINDINGS changes=$CHANGES tests=$TESTS"
      [ "$FINDINGS" -ge 1 ] && [ "$CHANGES" -ge 1 ] && [ "$TESTS" -ge 1 ] && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 4: build-test formula references CHANGES, TESTS, REVIEW
  - name: "build_test_comment_types"
    run: |
      F="$PLUGIN_DIR/plugins/yf/formulas/build-test.formula.json"
      CHANGES=$(grep -c 'CHANGES:' "$F")
      TESTS=$(grep -c 'TESTS:' "$F")
      REVIEW=$(grep -c 'REVIEW:' "$F")
      echo "changes=$CHANGES tests=$TESTS review=$REVIEW"
      [ "$CHANGES" -ge 1 ] && [ "$TESTS" -ge 1 ] && [ "$REVIEW" -ge 1 ] && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 5: research-spike formula references FINDINGS, CHANGES
  - name: "research_spike_comment_types"
    run: |
      F="$PLUGIN_DIR/plugins/yf/formulas/research-spike.formula.json"
      FINDINGS=$(grep -c 'FINDINGS:' "$F")
      CHANGES=$(grep -c 'CHANGES:' "$F")
      echo "findings=$FINDINGS changes=$CHANGES"
      [ "$FINDINGS" -ge 1 ] && [ "$CHANGES" -ge 1 ] && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 6: code-review formula references FINDINGS, REVIEW
  - name: "code_review_comment_types"
    run: |
      F="$PLUGIN_DIR/plugins/yf/formulas/code-review.formula.json"
      FINDINGS=$(grep -c 'FINDINGS:' "$F")
      REVIEW=$(grep -c 'REVIEW:' "$F")
      echo "findings=$FINDINGS review=$REVIEW"
      [ "$FINDINGS" -ge 1 ] && [ "$REVIEW" -ge 1 ] && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 7: All formulas have valid step dependency chains
  - name: "formula_step_dependencies_valid"
    run: |
      PASS=0
      FAIL=0
      for f in "$PLUGIN_DIR"/plugins/yf/formulas/*.formula.json; do
        NAME=$(basename "$f" .formula.json)
        # Check that all "needs" references point to existing step IDs
        STEP_IDS=$(jq -r '.steps[].id' "$f" | sort)
        NEEDS=$(jq -r '.steps[].needs[]?' "$f" 2>/dev/null | sort -u)
        VALID=true
        for need in $NEEDS; do
          if ! echo "$STEP_IDS" | grep -q "^${need}$"; then
            echo "INVALID: $NAME step needs '$need' but no such step ID"
            VALID=false
          fi
        done
        if $VALID; then
          PASS=$((PASS + 1))
        else
          FAIL=$((FAIL + 1))
        fi
      done
      echo "valid=$PASS invalid=$FAIL"
      [ "$FAIL" -eq 0 ] && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 8: Consolidated rules document all 4 protocol prefixes
  - name: "protocol_rule_has_all_prefixes"
    run: |
      RULE="$PLUGIN_DIR/plugins/yf/rules/yf-rules.md"
      FINDINGS=$(grep -c 'FINDINGS' "$RULE")
      CHANGES=$(grep -c 'CHANGES' "$RULE")
      REVIEW=$(grep -c 'REVIEW' "$RULE")
      TESTS=$(grep -c 'TESTS' "$RULE")
      echo "findings=$FINDINGS changes=$CHANGES review=$REVIEW tests=$TESTS"
      [ "$FINDINGS" -ge 1 ] && [ "$CHANGES" -ge 1 ] && [ "$REVIEW" -ge 1 ] && [ "$TESTS" -ge 1 ] && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 9: feature-build has no compose field (compose dropped per formula refactor)
  - name: "feature_build_no_compose"
    run: |
      COMPOSE=$(jq -r '.steps[] | select(.compose) | .compose' "$PLUGIN_DIR/plugins/yf/formulas/feature-build.formula.json")
      [ -z "$COMPOSE" ] && echo "OK: compose field absent" || echo "FAIL: compose field still present ($COMPOSE)"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 10: formula_execute has Step 3j chronicle auto-capture
  - name: "dispatch_has_progressive_chronicle"
    run: |
      grep -q '3j.*Auto-Capture Chronicle\|3j.*Progressive Chronicle' "$PLUGIN_DIR/plugins/yf/skills/formula_execute/SKILL.md" && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 11: formula_execute has Step 3k archive findings
  - name: "dispatch_has_archive_findings"
    run: |
      grep -q 'Step 3k.*Archive Findings\|Archive Findings.*Opt-In' "$PLUGIN_DIR/plugins/yf/skills/formula_execute/SKILL.md" && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 12: consolidated rules contain spec bridge content
  - name: "spec_bridge_in_rules"
    run: |
      grep -q 'engineer_suggest_updates' "$PLUGIN_DIR/plugins/yf/rules/yf-rules.md" && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 13: formula_execute E1 chronicle has structured execution narrative
  - name: "formula_execute_structured_chronicle"
    run: |
      grep -q 'structured execution narrative\|Step Results\|BLOCK verdicts\|Final outcome' "$PLUGIN_DIR/plugins/yf/skills/formula_execute/SKILL.md" && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 14: researcher agent has External sources subsection
  - name: "researcher_has_external_sources"
    run: |
      grep -q '### External' "$PLUGIN_DIR/plugins/yf/agents/yf_formula_researcher.md" && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 15: reviewer agent has IG reference section
  - name: "reviewer_has_ig_reference"
    run: |
      grep -q 'Implementation Guide Reference\|Specification Alignment' "$PLUGIN_DIR/plugins/yf/agents/yf_formula_reviewer.md" && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"

  # Case 16: consolidated rules contain archive bridge content
  - name: "archive_bridge_in_rules"
    run: |
      grep -q 'archive_capture' "$PLUGIN_DIR/plugins/yf/rules/yf-rules.md" && echo "OK"
    assertions:
      - type: output_contains
        value: "OK"
