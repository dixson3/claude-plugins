name: "Unit: plugin-preflight.sh — .claude/ to .yoshiko-flow/ migration"

setup:
  - "mkdir -p .claude/rules .yoshiko-flow docs/plans docs/diary"

steps:
  # Case 1: Old .claude/yf.json splits into config + lock
  - name: "migration_splits_config_and_lock"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow"
      mkdir -p "$WORK_DIR/.claude"
      cat > "$WORK_DIR/.claude/yf.json" <<'EOF'
      {
        "enabled": true,
        "config": {
          "artifact_dir": "docs",
          "chronicler_enabled": true,
          "archivist_enabled": false
        },
        "updated": "2026-02-10T00:00:00Z",
        "preflight": {
          "plugins": {
            "yf": {
              "version": "2.10.0",
              "mode": "symlink",
              "artifacts": {"rules": [], "directories": [], "setup": []}
            }
          }
        }
      }
      EOF
      CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "migrated .claude/yf.json"

  # Case 2: Config file has only config keys
  - name: "config_file_has_config_only"
    run: |
      if [ ! -f "$WORK_DIR/.yoshiko-flow/config.json" ]; then
        echo "FAIL: .yoshiko-flow/config.json not found"
        exit 1
      fi
      # Should have enabled and config, not updated or preflight
      HAS_ENABLED=$(jq 'has("enabled")' "$WORK_DIR/.yoshiko-flow/config.json")
      HAS_CONFIG=$(jq 'has("config")' "$WORK_DIR/.yoshiko-flow/config.json")
      HAS_PREFLIGHT=$(jq 'has("preflight")' "$WORK_DIR/.yoshiko-flow/config.json")
      HAS_UPDATED=$(jq 'has("updated")' "$WORK_DIR/.yoshiko-flow/config.json")
      echo "enabled=$HAS_ENABLED config=$HAS_CONFIG preflight=$HAS_PREFLIGHT updated=$HAS_UPDATED"
      if [ "$HAS_ENABLED" != "true" ] || [ "$HAS_CONFIG" != "true" ]; then
        echo "FAIL: config keys missing"
        exit 1
      fi
      if [ "$HAS_PREFLIGHT" = "true" ] || [ "$HAS_UPDATED" = "true" ]; then
        echo "FAIL: lock keys leaked into config"
        exit 1
      fi
      # Verify deprecated fields were pruned
      if jq -e '.config.archivist_enabled' "$WORK_DIR/.yoshiko-flow/config.json" >/dev/null 2>&1; then
        echo "FAIL: archivist_enabled should have been pruned"
        exit 1
      fi
      if jq -e '.config.chronicler_enabled' "$WORK_DIR/.yoshiko-flow/config.json" >/dev/null 2>&1; then
        echo "FAIL: chronicler_enabled should have been pruned"
        exit 1
      fi
      echo "OK: config file has config-only keys (deprecated fields pruned)"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 3: Lock file has lock keys
  - name: "lock_file_has_lock_keys"
    run: |
      if [ ! -f "$WORK_DIR/.yoshiko-flow/lock.json" ]; then
        echo "FAIL: .yoshiko-flow/lock.json not found"
        exit 1
      fi
      HAS_PREFLIGHT=$(jq 'has("preflight")' "$WORK_DIR/.yoshiko-flow/lock.json")
      HAS_UPDATED=$(jq 'has("updated")' "$WORK_DIR/.yoshiko-flow/lock.json")
      echo "preflight=$HAS_PREFLIGHT updated=$HAS_UPDATED"
      if [ "$HAS_PREFLIGHT" != "true" ] || [ "$HAS_UPDATED" != "true" ]; then
        echo "FAIL: lock keys missing"
        exit 1
      fi
      echo "OK: lock file has lock keys"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 4: Old .claude/yf.json is removed after migration
  - name: "old_config_removed"
    run: |
      if [ -f "$WORK_DIR/.claude/yf.json" ]; then
        echo "FAIL: old .claude/yf.json still exists"
        exit 1
      fi
      echo "OK: old config removed"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 5: State files migrate from .claude/ to .yoshiko-flow/
  - name: "state_files_migrate"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow"
      mkdir -p "$WORK_DIR/.claude"
      echo '{"dispatched":{}}' > "$WORK_DIR/.claude/.task-pump.json"
      echo '{"plan_idx":"05"}' > "$WORK_DIR/.claude/.plan-gate"
      touch "$WORK_DIR/.claude/.plan-intake-ok"
      # Create a config so preflight doesn't signal setup needed
      mkdir -p "$WORK_DIR/.yoshiko-flow"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "migrated .claude/.task-pump.json"

  # Case 6: Migrated state files exist at new paths
  - name: "state_files_at_new_paths"
    run: |
      FAIL=false
      for f in task-pump.json plan-gate plan-intake-ok; do
        if [ ! -e "$WORK_DIR/.yoshiko-flow/$f" ]; then
          echo "FAIL: .yoshiko-flow/$f not found"
          FAIL=true
        fi
      done
      # Old files should be gone
      for f in .task-pump.json .plan-gate .plan-intake-ok; do
        if [ -e "$WORK_DIR/.claude/$f" ]; then
          echo "FAIL: old .claude/$f still exists"
          FAIL=true
        fi
      done
      if $FAIL; then exit 1; fi
      echo "OK: state files at new paths"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 7: .yoshiko-flow/.gitignore is created
  - name: "gitignore_created"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow"
      CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1
      if [ ! -f "$WORK_DIR/.yoshiko-flow/.gitignore" ]; then
        echo "FAIL: .gitignore not created"
        exit 1
      fi
      # Should ignore everything except config.json
      if ! grep -q '!config.json' "$WORK_DIR/.yoshiko-flow/.gitignore"; then
        echo "FAIL: .gitignore missing !config.json"
        exit 1
      fi
      echo "OK: .gitignore created with correct content"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 8: Orphaned .claude/yf.json removed when .yoshiko-flow/config.json exists
  - name: "orphan_config_cleaned"
    run: |
      # Ensure both locations have configs
      mkdir -p "$WORK_DIR/.yoshiko-flow" "$WORK_DIR/.claude"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      echo '{"enabled":true,"config":{},"preflight":{"old":"data"}}' > "$WORK_DIR/.claude/yf.json"
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      if [ -f "$WORK_DIR/.claude/yf.json" ]; then
        echo "FAIL: orphaned .claude/yf.json not removed"
        exit 1
      fi
      if echo "$OUTPUT" | grep -q "removed orphaned .claude/yf.json"; then
        echo "OK: orphaned config cleaned up"
      else
        echo "OK: orphaned config cleaned up (already gone)"
      fi
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 9: Orphaned state files removed when new ones exist
  - name: "orphan_state_files_cleaned"
    run: |
      mkdir -p "$WORK_DIR/.yoshiko-flow" "$WORK_DIR/.claude"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      # Create both old and new state files
      echo '{"old":"data"}' > "$WORK_DIR/.claude/.task-pump.json"
      echo '{"new":"data"}' > "$WORK_DIR/.yoshiko-flow/task-pump.json"
      touch "$WORK_DIR/.claude/.plan-intake-ok"
      touch "$WORK_DIR/.yoshiko-flow/plan-intake-ok"
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      FAIL=false
      if [ -e "$WORK_DIR/.claude/.task-pump.json" ]; then
        echo "FAIL: orphaned .claude/.task-pump.json not removed"
        FAIL=true
      fi
      if [ -e "$WORK_DIR/.claude/.plan-intake-ok" ]; then
        echo "FAIL: orphaned .claude/.plan-intake-ok not removed"
        FAIL=true
      fi
      if $FAIL; then exit 1; fi
      echo "OK: orphaned state files cleaned up"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 10: Stale .claude/.gitignore with only yf entries is removed
  - name: "stale_claude_gitignore_cleaned"
    run: |
      mkdir -p "$WORK_DIR/.yoshiko-flow" "$WORK_DIR/.claude"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      echo 'yf.local.json' > "$WORK_DIR/.claude/.gitignore"
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      if [ -f "$WORK_DIR/.claude/.gitignore" ]; then
        echo "FAIL: stale .claude/.gitignore not removed"
        exit 1
      fi
      echo "OK: stale .claude/.gitignore removed"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 11: .claude/.gitignore with non-yf content is preserved
  - name: "claude_gitignore_with_user_content_preserved"
    run: |
      mkdir -p "$WORK_DIR/.yoshiko-flow" "$WORK_DIR/.claude"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      printf 'yf.local.json\nmy-custom-file.txt\n' > "$WORK_DIR/.claude/.gitignore"
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      if [ ! -f "$WORK_DIR/.claude/.gitignore" ]; then
        echo "FAIL: .claude/.gitignore with user content was removed"
        exit 1
      fi
      echo "OK: .claude/.gitignore with user content preserved"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 12: Idempotent re-run — no migration messages
  - name: "idempotent_rerun"
    run: |
      # First run to set up
      CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1 > /dev/null
      # Second run should not mention migration
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      if echo "$OUTPUT" | grep -q "migrated"; then
        echo "FAIL: migration ran again on re-run"
        exit 1
      fi
      echo "OK: idempotent re-run"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 13: yf.json renamed to config.json within .yoshiko-flow/
  - name: "yf_json_renamed_to_config_json"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow"
      mkdir -p "$WORK_DIR/.yoshiko-flow"
      echo '{"enabled":true,"config":{"artifact_dir":"docs","chronicler_enabled":true}}' > "$WORK_DIR/.yoshiko-flow/yf.json"
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      # yf.json should be gone
      if [ -f "$WORK_DIR/.yoshiko-flow/yf.json" ]; then
        echo "FAIL: .yoshiko-flow/yf.json still exists"
        exit 1
      fi
      # config.json should exist with preserved content
      if [ ! -f "$WORK_DIR/.yoshiko-flow/config.json" ]; then
        echo "FAIL: .yoshiko-flow/config.json not found"
        exit 1
      fi
      ENABLED=$(jq -r '.enabled' "$WORK_DIR/.yoshiko-flow/config.json")
      ARTIFACT=$(jq -r '.config.artifact_dir' "$WORK_DIR/.yoshiko-flow/config.json")
      if [ "$ENABLED" != "true" ] || [ "$ARTIFACT" != "docs" ]; then
        echo "FAIL: config content not preserved (enabled=$ENABLED, artifact_dir=$ARTIFACT)"
        exit 1
      fi
      echo "OK: yf.json renamed to config.json with content preserved"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "renamed .yoshiko-flow/yf.json"
      - type: output_contains
        value: "OK"

  # Case 14: Stale yf.json removed when config.json already exists
  - name: "stale_yf_json_removed_when_config_exists"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow"
      mkdir -p "$WORK_DIR/.yoshiko-flow"
      echo '{"enabled":true,"config":{"artifact_dir":"docs"}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      echo '{"enabled":false,"config":{}}' > "$WORK_DIR/.yoshiko-flow/yf.json"
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      # Stale yf.json should be removed
      if [ -f "$WORK_DIR/.yoshiko-flow/yf.json" ]; then
        echo "FAIL: stale .yoshiko-flow/yf.json not removed"
        exit 1
      fi
      # config.json should be untouched (still has artifact_dir)
      ARTIFACT=$(jq -r '.config.artifact_dir' "$WORK_DIR/.yoshiko-flow/config.json")
      if [ "$ARTIFACT" != "docs" ]; then
        echo "FAIL: config.json was modified (artifact_dir=$ARTIFACT)"
        exit 1
      fi
      echo "OK: stale yf.json removed, config.json untouched"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "removed stale .yoshiko-flow/yf.json"
      - type: output_contains
        value: "OK"

  # Case 15: .gitignore updated from !yf.json to !config.json
  - name: "gitignore_updated_from_yf_json_to_config_json"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow"
      mkdir -p "$WORK_DIR/.yoshiko-flow"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      # Write old-style .gitignore with !yf.json
      cat > "$WORK_DIR/.yoshiko-flow/.gitignore" <<'EOF'
      # Ignore everything except yf.json (config)
      *
      !.gitignore
      !yf.json
      EOF
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      # .gitignore should now whitelist config.json
      if ! grep -q '!config.json' "$WORK_DIR/.yoshiko-flow/.gitignore"; then
        echo "FAIL: .gitignore not updated to !config.json"
        cat "$WORK_DIR/.yoshiko-flow/.gitignore"
        exit 1
      fi
      # Should NOT whitelist yf.json anymore
      if grep -q '!yf.json' "$WORK_DIR/.yoshiko-flow/.gitignore"; then
        echo "FAIL: .gitignore still has !yf.json"
        exit 1
      fi
      echo "OK: .gitignore updated from !yf.json to !config.json"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK"

  # Case 16: Flat yf-*.md rule symlinks removed on upgrade to yf/ subdirectory
  - name: "flat_yf_rules_removed_on_upgrade"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow" "$WORK_DIR/.claude/rules/yf"
      mkdir -p "$WORK_DIR/.yoshiko-flow" "$WORK_DIR/.claude/rules"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      # Create old-style lock with flat yf-*.md targets
      cat > "$WORK_DIR/.yoshiko-flow/lock.json" <<'EOF'
      {
        "updated": "2026-02-01T00:00:00Z",
        "preflight": {
          "plugins": {
            "yf": {
              "version": "2.10.0",
              "mode": "symlink",
              "artifacts": {
                "rules": [
                  {"target": ".claude/rules/yf-beads.md", "link": "../../plugins/yf/rules/yf-beads.md"},
                  {"target": ".claude/rules/yf-engage-the-plan.md", "link": "../../plugins/yf/rules/yf-engage-the-plan.md"}
                ],
                "directories": [],
                "setup": []
              }
            }
          }
        }
      }
      EOF
      # Create old-style flat symlinks
      ln -sf "../../plugins/yf/rules/yf-beads.md" "$WORK_DIR/.claude/rules/yf-beads.md"
      ln -sf "../../plugins/yf/rules/yf-engage-the-plan.md" "$WORK_DIR/.claude/rules/yf-engage-the-plan.md"
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      # Old flat symlinks should be removed
      FAIL=false
      if [ -e "$WORK_DIR/.claude/rules/yf-beads.md" ] || [ -L "$WORK_DIR/.claude/rules/yf-beads.md" ]; then
        echo "FAIL: old flat yf-beads.md still exists"
        FAIL=true
      fi
      if [ -e "$WORK_DIR/.claude/rules/yf-engage-the-plan.md" ] || [ -L "$WORK_DIR/.claude/rules/yf-engage-the-plan.md" ]; then
        echo "FAIL: old flat yf-engage-the-plan.md still exists"
        FAIL=true
      fi
      # New yf/ subdirectory symlinks should exist
      if [ ! -L "$WORK_DIR/.claude/rules/yf/beads.md" ]; then
        echo "FAIL: new yf/beads.md symlink not created"
        FAIL=true
      fi
      if [ ! -L "$WORK_DIR/.claude/rules/yf/engage-the-plan.md" ]; then
        echo "FAIL: new yf/engage-the-plan.md symlink not created"
        FAIL=true
      fi
      if $FAIL; then exit 1; fi
      echo "OK: flat symlinks removed, yf/ subdirectory symlinks created"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "removed stale"
      - type: output_contains
        value: "OK"

  # Case 17: .gitignore updated from flat glob to subdirectory entry
  - name: "gitignore_updated_from_flat_to_subdir"
    run: |
      rm -rf "$WORK_DIR/.yoshiko-flow"
      mkdir -p "$WORK_DIR/.yoshiko-flow"
      echo '{"enabled":true,"config":{}}' > "$WORK_DIR/.yoshiko-flow/config.json"
      # Write old-style .gitignore with flat glob
      cat > "$WORK_DIR/.gitignore" <<'EOF'
      # >>> yf-managed >>>
      # Beads issue tracker (local-only)
      .beads/

      # Plugin-managed rule symlinks
      .claude/rules/yf-*.md
      # <<< yf-managed <<<
      EOF
      OUTPUT=$(CLAUDE_PROJECT_DIR="$WORK_DIR" bash "$PLUGIN_DIR/plugins/yf/scripts/plugin-preflight.sh" 2>&1)
      echo "$OUTPUT"
      # .gitignore should now have yf/ directory entry
      if grep -q '.claude/rules/yf/' "$WORK_DIR/.gitignore"; then
        echo "OK: .gitignore has yf/ directory entry"
      else
        echo "FAIL: .gitignore missing yf/ directory entry"
        cat "$WORK_DIR/.gitignore"
        exit 1
      fi
      # Should NOT have the old glob pattern
      if grep -q 'yf-\*\.md' "$WORK_DIR/.gitignore"; then
        echo "FAIL: .gitignore still has old glob pattern"
        exit 1
      fi
      echo "OK: .gitignore updated from flat glob to subdirectory"
    assertions:
      - type: exit_code
        value: "0"
      - type: output_contains
        value: "OK: .gitignore has yf/ directory entry"
      - type: output_contains
        value: "OK: .gitignore updated"
