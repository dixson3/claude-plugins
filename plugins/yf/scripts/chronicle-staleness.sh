#!/usr/bin/env bash
# chronicle-staleness.sh — Create checkpoint chronicle when work goes stale
#
# Detects when in-progress tasks exist but no recent chronicle entry has been
# created. Creates a checkpoint chronicle to prevent context loss during long
# sessions.
#
# Usage:
#   bash chronicle-staleness.sh [--threshold <hours>]
#
# Options:
#   --threshold <hours>  Hours since last chronicle before triggering (default: 2)
#
# Compatible with bash 3.2+ (macOS default).
# Exit 0 always (fail-open).

set -uo pipefail

# --- Source config library and task library ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
. "$SCRIPT_DIR/yf-config.sh"
. "$SCRIPT_DIR/yf-tasks.sh"

# --- Guards ---
yf_is_enabled || exit 0

if ! command -v jq >/dev/null 2>&1; then
  exit 0
fi

# --- Parse arguments ---
THRESHOLD_HOURS=2

while [ $# -gt 0 ]; do
  case $1 in
    --threshold|-t)
      THRESHOLD_HOURS="$2"
      shift 2
      ;;
    --help|-h)
      echo "Usage: chronicle-staleness.sh [--threshold <hours>]"
      exit 0
      ;;
    *)
      shift
      ;;
  esac
done

# --- Project directory ---
PROJECT_DIR="${CLAUDE_PROJECT_DIR:-.}"

# --- Dedup: one check per hour ---
DEDUP_DIR="${PROJECT_DIR}/.yoshiko-flow"
DEDUP_FILE="${DEDUP_DIR}/.chronicle-staleness-$(date +%Y%m%d)"
DEDUP_KEY="staleness-check-$(date +%H)"

mkdir -p "$DEDUP_DIR" 2>/dev/null || true

if [ -f "$DEDUP_FILE" ] && grep -qF "$DEDUP_KEY" "$DEDUP_FILE" 2>/dev/null; then
  exit 0
fi

# --- Check for in-progress tasks ---
IN_PROGRESS=$(yft_list --status=in_progress --type=task --limit=0 --json 2>/dev/null || echo "[]")
IN_PROGRESS_COUNT=$(echo "$IN_PROGRESS" | jq 'length' 2>/dev/null || echo "0")

if [ "$IN_PROGRESS_COUNT" -eq 0 ]; then
  exit 0
fi

# --- Check for recent chronicle entries ---
# Get the most recent chronicle entry's creation date
LATEST_CHRONICLE=$(yft_list -l "ys:chronicle" --status=open --limit=1 --json 2>/dev/null || echo "[]")
LATEST_CREATED=$(echo "$LATEST_CHRONICLE" | jq -r '.[0].created // empty' 2>/dev/null || true)

STALE=false
if [ -z "$LATEST_CREATED" ]; then
  # No chronicle entries at all — definitely stale if work is in progress
  STALE=true
else
  # Compare creation time to threshold
  # Parse ISO date to epoch (portable approach)
  CHRONICLE_EPOCH=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${LATEST_CREATED%%.*}" "+%s" 2>/dev/null \
    || date -d "${LATEST_CREATED}" "+%s" 2>/dev/null \
    || echo "0")
  NOW_EPOCH=$(date "+%s")
  THRESHOLD_SECS=$((THRESHOLD_HOURS * 3600))
  ELAPSED=$((NOW_EPOCH - CHRONICLE_EPOCH))

  if [ "$ELAPSED" -gt "$THRESHOLD_SECS" ]; then
    STALE=true
  fi
fi

if ! $STALE; then
  exit 0
fi

# --- Mark dedup before creating (prevents racing) ---
echo "$DEDUP_KEY" >> "$DEDUP_FILE" 2>/dev/null || true

# --- Detect plan context ---
PLAN_LABEL=""
PLAN_EPIC=$( (set +e; yft_list --type=epic --status=open -l "exec:executing" --json 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null) || true)
if [ -n "$PLAN_EPIC" ]; then
  PLAN_LABEL=$( (set +e; yft_label_list "$PLAN_EPIC" --json 2>/dev/null | jq -r '.[] | select(startswith("plan:"))' 2>/dev/null | head -1) || true)
fi

# --- Get in-progress task titles ---
IN_PROGRESS_TITLES=$(echo "$IN_PROGRESS" | jq -r '.[0:5] | .[].title' 2>/dev/null || true)

# --- Create checkpoint chronicle entry ---
TITLE="Chronicle (Checkpoint): ${IN_PROGRESS_COUNT} tasks in progress"
DESCRIPTION="## Staleness Checkpoint

**Trigger**: No chronicle in ${THRESHOLD_HOURS}+ hours with active work
**Date**: $(date +%Y-%m-%d\ %H:%M)
**In-progress tasks**: ${IN_PROGRESS_COUNT}

## Active Work
${IN_PROGRESS_TITLES}

Auto-generated by chronicle-staleness.sh to prevent context loss."

LABELS="ys:chronicle,ys:chronicle:checkpoint"
if [ -n "$PLAN_LABEL" ]; then
  LABELS="${LABELS},${PLAN_LABEL}"
fi

yft_create --type=chronicle --priority=3 \
  -l "$LABELS" \
  --title "$TITLE" \
  --description "$DESCRIPTION" >/dev/null 2>&1 || true

exit 0
