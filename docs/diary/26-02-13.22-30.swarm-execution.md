# Diary Entry: Swarm-Enhanced Plan Execution (v2.13.0)

**Date**: 2026-02-13 22:30
**Operator**: James Dixson
**Topics**: feature, swarm, planning
**Chronicle IDs**: marketplace-puy

## Summary

We had been running plan execution as a serial, single-agent process since the plan lifecycle was introduced, and it was time to break that ceiling. James wanted formula-driven parallel agent workflows layered onto the existing plan lifecycle, leveraging beads formulas, wisps (ephemeral molecules), and structured comment protocols for inter-agent communication. We built the entire v2.13.0 swarm capability in a single session.

The implementation spanned 20 tasks across 5 phases -- foundation, agents, skills, rules/integration, and documentation -- creating 17 new files and modifying 9 existing ones. We started at the foundation layer with `swarm-state.sh`, adapted from the existing `pump-state.sh` to track dispatch state for swarm steps. Five formula JSON files defined the reusable workflow patterns: `feature-build` (research, implement, review) as the workhorse pattern, `research-spike` (investigate, synthesize, archive) with auto-archive integration, `code-review` (analyze, report) for read-only analysis, `bugfix` (diagnose, fix, verify), and `build-test` (implement, test, review).

Three specialized swarm agents came next, each with structured comment protocols: `yf_swarm_researcher` posts `FINDINGS:` in archivist-compatible format, `yf_swarm_reviewer` posts `REVIEW:PASS` or `REVIEW:BLOCK`, and `yf_swarm_tester` posts `TESTS:` with pass/fail results. These agents communicate exclusively through beads comments, creating a machine-parseable audit trail that survives wisp squashing.

The skill layer tied everything together with four skills covering the full lifecycle: `swarm_run` as the entry point for instantiating formulas as wisps, `swarm_dispatch` as the core dispatch loop parsing `SUBAGENT:` annotations and dispatching parallel Task calls, `swarm_status` for monitoring, and `swarm_list_formulas` for discovery. We then wired the swarm into the existing chronicler and archivist subsystems through six integration enhancements -- swarm completion auto-chronicles, diary reading of swarm comments, wisp squash detection, research-spike auto-archives, a swarm-archive bridge rule, and researcher-archivist format alignment. All 443 unit tests passed, including 8 new tests for `swarm-state.sh`.

## Decisions

- **Gate type unavailable**: The `--type=gate` flag produced validation errors in this rig, so execution gates were created as tasks with `ys:gate` labels instead.
- **SUBAGENT annotations in descriptions**: Agent routing metadata (`SUBAGENT:Explore`, `SUBAGENT:general-purpose`) is embedded in formula step descriptions and parsed by the dispatch skill, keeping beads-generic and yf-specific concerns separated.
- **Comment protocol design**: Structured prefixes (`FINDINGS:`, `CHANGES:`, `REVIEW:`, `TESTS:`) provide both machine-parseable routing and human-readable audit trails that survive wisp squashing.
- **Research-spike includes archive step**: The third step in research-spike creates an `ys:archive` bead from FINDINGS, bridging operational research into permanent documentation.

## Next Steps

- [ ] Verify formula cooking with `bd cook --dry-run`
- [ ] End-to-end test with `/yf:swarm_run formula:feature-build`
- [ ] Test plan integration with `formula:` labeled tasks

---
*Generated by chronicler from 1 chronicle bead*
