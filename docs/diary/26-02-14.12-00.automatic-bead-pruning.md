# Diary Entry: Automatic Bead Pruning

**Date**: 2026-02-14 12:00
**Operator**: James Dixson
**Topics**: feature, pruning, automation
**Chronicle IDs**: marketplace-1zh, marketplace-stz

## Summary

The beads database had been growing unchecked since the project began, and by the time we looked at it, 278 closed beads were sitting idle. Plan 30 started as a manual cleanup -- we pruned all 278 in one pass, confirming that no content was lost since everything meaningful had already been captured in diary entries, plan documents, and the CHANGELOG. That manual exercise convinced James that pruning should be automatic, which led directly to Plan 32.

Plan 32 systematized the manual process into automatic pruning at two trigger points. We built `plan-prune.sh` with two subcommands: `plan <label>` for soft-deleting closed beads scoped to a specific plan, and `global` for running `bd admin cleanup` against all stale closed beads older than a configurable threshold (default 7 days) plus ephemeral wisps. Both subcommands are fail-open and configurable via `.yoshiko-flow/config.json` under the `auto_prune` key.

The integration points made pruning invisible to the normal workflow. We wired plan-scoped pruning into `plan-exec.sh`, calling it in a fail-open subshell when status returns `completed`. For global pruning, a new `PostToolUse` hook (`post-push-prune.sh`) runs after `git push`, then syncs the pruned state to the `beads-sync` branch. The two-step push sequence ensures code is safely remote before any cleanup begins. In a satisfying bit of self-reference, the auto-prune fired during its own implementation -- when Plan 32 completed, `plan-exec.sh status` automatically pruned 12 closed beads.

## Decisions

- **Soft delete only** -- tombstones with 30-day recovery window, never hard deletes, preventing resurrection issues from old beads-sync clones
- **Fail-open everywhere** -- prune errors never block plan completion or push operations (exit 0 always)
- **PostToolUse over PreToolUse** -- prune runs *after* the push succeeds, ensuring code is safely remote before any cleanup
- **Two-step push sequence** -- code pushes first, then prune runs, then `bd sync` pushes the pruned beads state as an incremental update to beads-sync

## Artifacts

- `plugins/yf/scripts/plan-prune.sh` -- core prune script (plan/global subcommands, --dry-run)
- `plugins/yf/hooks/post-push-prune.sh` -- PostToolUse hook for global prune on push
- `plugins/yf/scripts/yf-config.sh` -- added `yf_is_prune_on_complete()`, `yf_is_prune_on_push()`
- `plugins/yf/scripts/plan-exec.sh` -- integrated plan-scoped prune at completion
- `plugins/yf/.claude-plugin/plugin.json` -- added PostToolUse hook section, v2.15.0
- `tests/scenarios/unit-plan-prune.yaml` -- 8 test cases
- `tests/scenarios/unit-yf-config.yaml` -- 4 new config test cases (cases 8-11)

## Live Verification

The auto-prune fired during its own implementation: when plan-32 completed, `plan-exec.sh status` automatically pruned 12 closed beads. Self-testing in production.

## Next Steps

- [ ] Manual verification: complete a plan, confirm closed beads pruned
- [ ] Manual verification: `git push`, confirm global cleanup runs
- [ ] Config test: set `on_plan_complete: false`, confirm prune skipped

---
*Generated by chronicler from 2 chronicle beads*
