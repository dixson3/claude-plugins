# Plan: Bash Script Quick Wins — Reduce Complexity in yf Plugin Scripts

## Context

Audit of 23 scripts + 11 hooks in `plugins/yf/` revealed that `yf-tasks.sh` (the core task management library) spawns excessive jq subprocesses, has fragile string parsing, and carries dead code. Several smaller scripts have copy-pasted blocks that could consolidate. This plan applies targeted bash-only fixes — no Python migration — prioritized by impact.

## Fixes (6 items, ordered by implementation sequence)

### Fix 1: Replace `sed` with parameter expansion in `yft_comment()` (trivial)
**File**: `plugins/yf/scripts/yf-tasks.sh:743-745`

Replace 2 `sed` subshells with bash builtins:
```bash
# Before:
protocol=$(echo "$raw_comment" | sed 's/:.*//')
content=$(echo "$raw_comment" | sed 's/^[^:]*: *//')

# After:
protocol="${raw_comment%%:*}"
content="${raw_comment#*: }"
```
Eliminates 2 subshell forks. Also fixes edge case where content containing colons could be truncated.

### Fix 2: Remove dead `yft_mol_show()` alias (trivial)
**Files**:
- `plugins/yf/scripts/yf-tasks.sh:881-884` — delete function
- `plugins/yf/scripts/yf-task-cli.sh:72` — change `yft_mol_show` to `yft_show`

### Fix 3: Batch jq calls in `yft_update()` (high impact)
**File**: `plugins/yf/scripts/yf-tasks.sh:415-454`

Currently spawns 2-7 separate jq processes per update call. Replace with a single jq invocation that builds a filter expression dynamically:
- Accumulate `jq_args` array and `jq_filter` string
- One `jq` call reads from file directly, applies all mutations, writes to tmp
- Labels CSV-to-array still needs its own `jq -R -s` call (different operation)
- Remove the intermediate `content=$(cat "$file")` variable

Net result: **1-2 jq calls** instead of 2-7.

### Fix 4: Batch jq in `yft_mol_wisp()` vars loop (medium impact)
**File**: `plugins/yf/scripts/yf-tasks.sh:844-849`

Replace per-variable jq loop with single invocation:
- Build indexed `--arg k0 ... --arg v0 ...` array
- Build matching jq expression `. | . + {($k0): $v0} | . + {($k1): $v1} ...`
- Single `echo '{}' | jq` call

### Fix 5: Parametrize prune boolean checkers in `yf-config.sh` (low)
**File**: `plugins/yf/scripts/yf-config.sh:111-118`

Add generic `yf_is_prune()` function, keep named wrappers for backward compat:
```bash
yf_is_prune() { _yf_check_flag ".config.auto_prune.$1"; }
yf_is_prune_on_complete()      { yf_is_prune on_plan_complete; }
yf_is_prune_on_push()          { yf_is_prune on_push; }
yf_is_prune_on_session_close() { yf_is_prune on_session_close; }
```

### Fix 6: Consolidate `chronicle-validate.sh` boundary checks (low)
**File**: `plugins/yf/scripts/chronicle-validate.sh:53-107`

Replace 3 copy-pasted boundary blocks (~55 lines) with a loop over boundary specs (~30 lines):
```bash
BOUNDARY_SPECS=("save|intake save/intake" "start start" "complete complete")
for spec in "${BOUNDARY_SPECS[@]}"; do ... done
```

### Deferred: Shared arg parsing helper
Skip — under bash 3.2 constraints (no associative arrays), the effort/benefit ratio is unfavorable. Each block is short and locally readable.

## Critical Files
- `plugins/yf/scripts/yf-tasks.sh` — Fixes 1-4 (primary target)
- `plugins/yf/scripts/yf-task-cli.sh:72` — Fix 2 (update mol show dispatch)
- `plugins/yf/scripts/yf-config.sh:111-118` — Fix 5
- `plugins/yf/scripts/chronicle-validate.sh:53-107` — Fix 6

## Verification

1. Run baseline: `bash tests/run-tests.sh --unit-only`
2. After Fixes 1-4: `bash tests/run-tests.sh --unit-only --scenarios tests/scenarios/unit-yf-tasks.yaml tests/scenarios/unit-yf-task-cli.yaml`
3. After Fix 5: `bash tests/run-tests.sh --unit-only --scenarios tests/scenarios/unit-yf-config.yaml`
4. After Fix 6: `bash tests/run-tests.sh --unit-only --scenarios tests/scenarios/unit-plan-chronicle.yaml`
5. Final full suite: `bash tests/run-tests.sh --unit-only`

Add new test cases for:
- Combined multi-field update (Fix 3)
- `yft_mol_wisp` with multiple `--var` args (Fix 4)
- Comment containing colons in content (Fix 1)
